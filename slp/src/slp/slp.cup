package slp;

import java_cup.runtime.*;



/**********************/
/* TERMINALS (TOKENS) */
/**********************/
terminal ASSIGN;
terminal BOOLEAN;
terminal BREAK;
terminal CLASS;
terminal COMMA;
terminal CONTINUE;
terminal DIVIDE;
terminal DOT;
terminal EQUAL;
terminal EXTENDS;
terminal ELSE;
terminal FALSE;
terminal GT;
terminal GTE;
terminal IF;
terminal INT;
terminal LAND;
terminal MULTIPLY;
terminal LP;

//Lior
terminal LB;
terminal LCBR;
terminal LENGTH;
terminal NEW;
terminal LNEG;
terminal LOR;
terminal LT;
terminal LTE;
terminal MINUS;
terminal MOD;
terminal NEQUAL;

//Tomer
terminal NULL;
terminal PLUS;
terminal RB;
terminal RCBR;
terminal RETURN;
terminal RP;
terminal SEMI;
terminal STATIC;
terminal STRING;
terminal THIS;
terminal TRUE;
terminal VOID;
terminal WHILE;
 
/**********************/
/* TERMINALS (TOKENS) */
/**********************/
terminal Integer	NUMBER;
terminal String		ID;
terminal String		CLASS_ID;
terminal String		QUOTE;

/**********************/
/* 	 NON TERMINALS 	  */
/**********************/
non terminal Expr expr;
non terminal List<Expr> expr_list;
non terminal Location location;
non terminal Call call;
non terminal StaticCall static_call;
non terminal VirtualCall virtual_call;
non terminal BinaryOpExpr binop;
non terminal UnaryOpExpr unop;
non terminal Literal literal;
non terminal Type type;
/**********************/
/* 	   PRECEDENCE 	  */
/**********************/
precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL,NEQUAL;
precedence left LT,LTE,GT,GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right LNEG;
precedence left DOT, RP, LP, LB, RB;

/**********************/
/* 	DERIVATION RULES  */
/**********************/
expr ::= location:l
	{:	RESULT = l; :}
	|	call:c
	{:	RESULT = c; :}
	|	THIS:t
	{:	RESULT = new This(tleft); :}
	|	NEW CLASS_ID:cid LP RP
	{:	RESULT = new NewObject(cidleft, cid); :}
	|	NEW type:t LB expr:e RB
	{:	RESULT = new NewArray(t,e); :}
	|	expr:e DOT LENGTH
	{:	RESULT = new Length(e); :}
	|	binop:b
	{:	RESULT = b; :}
	|	unop:u
	{:	RESULT = u; :}
	|	literal:lit
	{:	RESULT = lit; :}
	|	LP expr:e RP
	{:	RESULT = e; :}
;

call ::= static_call:sc
	{:	RESULT = sc; :}
	|	virtual_call:vc
	{:	RESULT = vc; :}
;

expr_list ::= expr:e
	{:	List<Expr> explst = new ArrayList<Expr>();
		explst.add(e);
		RESULT = explst;
	:}
	| expr_list:explst COMMA expr:e
	{:	explst.add(e);
		RESULT = explst;
	:}
;

static_call ::= CLASS_ID:cid DOT ID:id LP RP
	{:	RESULT = new StaticCall(cidleft, cid, id, new ArrayList<Expr>()); :}
	|	CLASS_ID:cid DOT ID:id LP expr_list:explst RP
	{:	RESULT = new StaticCall(cidleft, cid, id, explst); :}
;

virtual_call ::= ID:id LP RP
	{:	RESULT = new VirtualCall(idleft, id, new ArrayList<Expr>()); :}
	|	expr:e DOT ID:id LP RP
	{:	RESULT = new VirtualCall(idleft, id, new ArrayList<Expr>(), e); :}
	|	ID:id LP expr_list:explst RP
	{:	RESULT = new VirtualCall(idleft, id, explst); :}
	|	expr:e DOT ID:id LP expr_list:explst RP
	{:	RESULT = new VirtualCall(idleft, id, explst, e); :}
;

location ::= ID:id
	{:	RESULT = new VarLocation(idleft, id); :}
	|	expr:e DOT ID:id
	{:	RESULT = new VarLocation(idleft, id,e); :}
	|	expr:e1 LB expr:e2 RB
	{:	RESSULT = new ArrLocation(e1,e2); :}
;

binop ::= expr:e1 PLUS expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.PLUS); :}
	|	expr:e1 MINUS expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.MINUS); :}
	|	expr:e1 MULTIPLY expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.MULTIPLY); :}
	|	expr:e1 DIVIDE expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.DIVIDE); :}
	|	expr:e1 MOD expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.MOD); :}
	|	expr:e1 LAND expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.LAND); :}
	|	expr:e1 LOR expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.LOR); :}
	|	expr:e1 LT expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.LT); :}
	|	expr:e1 GT expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.GT); :}
	|	expr:e1 LTE expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.LTE); :}
	|	expr:e1 GTE expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.GTE); :}
	|	expr:e1 EQUAL expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.EQUAL); :}
	|	expr:e1 NEQUAL expr:e2
	{:	RESULT = new BinaryOpExpr(e1,e2,BinOperator.NEQUAL); :}
;

unop ::= LNEG expr:e
	{:	RESULT = new UnaryOpExpr(e, UnOperator.LNEG); :}
;

literal ::= NUMBER:i
	{:	RESULT = new Literal(ileft, LiteralType.INTEGER, i); :}
	|	QUOTE:q
	{:	RESULT = new Literal(qleft, LiteralType.STRING, q); :}
	|	TRUE:t
	{:	RESULT = new Literal(tleft, LiteralType.TRUE); :}
	|	FALSE:f
	{:	RESULT = new Literal(fleft, LiteralType.FALSE); :}
	|	NULL:n
	{:	RESULT = new Literal(nleft, LiteralType.NULL); :}
;