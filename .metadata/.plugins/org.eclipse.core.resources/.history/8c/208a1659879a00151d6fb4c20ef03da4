package types;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import semantic.SemanticError;
import slp.ClassDecl;

/**
 * Main class to hold the type table for the input program
 *
 */
public class TypeTable {
    private static Map<String,TypeClass> programClasses = new HashMap<String,TypeClass>();
    private static Map<Type,TypeArray> programArrays = new HashMap<Type,TypeArray>();
    private static Map<String,TypeMethod> programMethods = new HashMap<String,TypeMethod>();
    private static Map<String,Type> programPrimitives = new HashMap<String,Type>();
    
    public static Map<String, Type> getProgramPrimitives() {
		return programPrimitives;
	}

	protected static int idCounter = 0;
    private static String icFileName = null;
    
    /**
     * initialize the type table
     */
    public static void initTypeTable(String icFileName){
    	programPrimitives.put("int", new TypeInt());
    	programPrimitives.put("boolean", new TypeBoolean());
    	programPrimitives.put("null", new TypeNull());
    	programPrimitives.put("string", new TypeString());
    	programPrimitives.put("void", new TypeVoid());
    	TypeTable.icFileName = icFileName;
    }
    
    /**
     * getter for the ic program file name
     */
    public static String getFileName(){
    	return icFileName;
    }

    /**
     *  Returns unique array type object
     * 
     */
    public static TypeArray typeArray(Type elemType) {
       if (programArrays.containsKey(elemType)) {
          // array type object already created – return it
          return programArrays.get(elemType);
       }
       else {
          // object doesn't exist – create and return it
          TypeArray arrt = new TypeArray(elemType);
          programArrays.put(elemType,arrt);
          return arrt;
       }
    }
    
    /**
     * Adds a new TypeClass entry to TypeTable. If the class is already defined
     * or extends a class that was not previously defined, throws SemanticError. 
     * @param c
     * @throws SemanticError
     */
    public static void addTypeClass(ClassDecl c) throws SemanticError{
    	if (programClasses.containsKey(c.getName())){ 
    		throw new SemanticError("class already defined: "+c.getName(), c.getLineNum());
    	}
    	if (c.getSuperClassName() == null) {
    		if (!programClasses.containsKey(c.getSuperClassName()))
    			throw new SemanticError("super-class is undefined: " +c.getSuperClassName(),c.getLineNum());
    	}
    	
    	TypeClass ct = new TypeClass(c);
    	programClasses.put(c.getName(),ct);
    }
    
    /** 
     * Returns unique class type object
     */
    public static TypeClass getTypeClass(String name) throws SemanticError{
    	TypeClass ct = programClasses.get(name);
    	if (ct == null) throw new SemanticError("class is undefined: "+ name);
    	else return ct;
    }
    
    public static TypeMethod typeMethod(String name,Type returnType, List<Type> paramTypes){
    	TypeMethod mt = new TypeMethod(name,returnType,paramTypes);
    	String key = mt.toString();
    	
    	TypeMethod mt2 = programMethods.get(key);
    	if (mt2 == null) {
    		programMethods.put(key, mt);
    		return mt;
    	} else return mt2;
    	
    }
    
    /**
     * A getter that gets a String and returns the type
     */
    public static Type getType(String typeName) throws SemanticError{
    	Type t;
    	
    	// case primitive type
    	t = programPrimitives.get(typeName);
    	if (t != null) return t;
    	// case array type
    	if (typeName.endsWith("[]")) return typeArray(getType(typeName.substring(0, typeName.length()-2)));
    	// case class type
    	else return getTypeClass(typeName);
    }
    
    
    /**
     * Checks whether the name is of a primitive type (except for null or string).
     * @param name - type name.
     * @return true if type is primitive, false otherwise.
     */
    public static boolean isPrimitive(String name){
    	return ((name == "int") || (name == "boolean") || (name == "void"));
    }
    
}
