package lir;

import semantic.SemanticError;
import semantic.TypeEvaluator;
import slp.*;
import symbolTableHandler.*;
import types.TypeArray;

/**
 * Class traverses the global symbol table,
 * and translates the program into LIR code.
 * 
 * each visit is passed the LIR program Environment,
 * that contains the information regarding the LIR code and registers.
 * 
 * setting the program variable labels is done in VarLabelVisitor before is run LirVisitor.
 */
public class LirVisitor implements PropagatingVisitor<Environment,LirReturnInfo>{

	private GlobalSymbolTable globalSymTable = null;
	private Environment environment = null;

	public LirVisitor(GlobalSymbolTable globalSymTable){
		this.globalSymTable = globalSymTable;
	}

	public String getLirCode(Program program){
		environment = new Environment();
		visit(program,environment);
		return environment.generateLirCode();
	}

	public LirReturnInfo visit(Program program, Environment d) {

		//all checks are done in Environment instance
		//therefore, nothing to be done in current visit

		//create Dispatcher table
		//traverse all classes before visiting all methods 
		//as class methods can be called before class declaration
		for(ClassDecl c: program.getClasses()){
			if (!c.getName().equals("Library")){
				//create dispatcher table
				ClassSymbolTable classSymT = globalSymTable
						.getClassSymbolTable(c.getName());			

				if(c.getSuperClassName() != null){
					d.addVirtualTable(c.getName(), c.getSuperClassName(),
							classSymT.getAllVirtualMethods());
				}else{
					d.addVirtualTable(c.getName(), classSymT.getAllVirtualMethods());
				}
			}
		}

		//visit all classes apart from Library
		for(ClassDecl c: program.getClasses()){
			if (!c.getName().equals("Library"))
				c.accept(this, d);
		}

		//nothing to be returned
		return null;
	}

	public LirReturnInfo visit(ClassDecl class_decl, Environment d) {

		//Dispatcher table is already done so we continue visit the methods		
		for(FieldOrMethod fom : class_decl.getFieldsOrMethods()){
			fom.accept(this, d);
		}

		//nothing to be returned				
		return null;
	}

	public LirReturnInfo visit(Field field, Environment d) {
		// nothing to be done here
		//offset id already handled by symbolTable 
		return null;
	}

	/**
	 * Common handler for static and virtual methods
	 */
	private void methodVisitor(Method method, Environment d) {

		//get current updated lir code
		StringBuilder strb = d.getLirStringBuilder();

		//add new line
		strb.append("\n");

		//get class name for comment and label
		String class_name = ((ClassSymbolTable)method.getScope()).getSymbol().getName();

		//add Relevant Label
		if(method.getName().equals("main")){
			//if name == main then it must be the static main function by IC specification	

			//add comment with method and class name
			strb.append("####main in "+class_name+"####\n");

			//add label
			strb.append("_ic_main:\n");			
		} else {
			//not main function

			//add comment with method and class name
			strb.append("####"+class_name+"."+method.getName()+"####\n");

			//add label
			strb.append("_"+class_name+"_"+method.getName()+":\n");					
		}

		//visit all statements
		method.getStatementList().accept(this, d);

		//return 9999 if function return type is void
		if(method.getType().getFullName().equals("void")){
			strb.append("Return 9999\n");
		}

	}


	/**
	 * Translate Static Method into LIR code
	 */
	public LirReturnInfo visit(StaticMethod staticMethod, Environment d) {
		methodVisitor(staticMethod,d);
		return null; //nothing to be returned
	}


	/**
	 * Translate Class (virtual) Method into LIR code
	 */
	public LirReturnInfo visit(ClassMethod classMethod, Environment d) {
		methodVisitor(classMethod,d);
		return null; //nothing to be returned
	}


	/**
	 * PrimitiveType translation to LIR  code
	 * no addition of LIR code required
	 */	
	public LirReturnInfo visit(PrimitiveType primitiveType, Environment d) {
		return null;
	}


	/**
	 * user define ClassType translation to LIR  code
	 * no addition of LIR code required
	 */
	public LirReturnInfo visit(ClassType classType, Environment d) {
		return null;
	}


	/**
	 * Formal translation to LIR  code
	 */
	public LirReturnInfo visit(Formal formal, Environment d) {
		// get LIR code of the formal's type
		return formal.getType().accept(this, d);
	}

	/***
	 * Checks if the given input string represents a variable in memory
	 * @param var
	 * @return if var is in Memory
	 */
	private boolean isMemoryVar(String var){
		// local variable
		if(var.startsWith("v_")){
			return true;
		}
		// method parameter
		if(var.startsWith("p_")){
			return true;
		}
		// object's this
		if(var.startsWith("this")){
			return true;
		}
		
		return false;
	}

	/***
	 * Function to handle the possible assignments (moves) in LIR
	 * @param location - register, memory, field or array-location
	 * @param value - immediate, register or memory
	 * @param lineNum - line number in translated code
	 * @param d - the current LIR environment
	 */
	private void lirAssignHandler(String location, String value, int lineNum, Environment d){

		// handle a move to a register
		if(location.startsWith("R")){
			d.addLirInstruction(MoveEnum.MOVE, value, location, lineNum);
		}

		// handle a move to memory
		else if(isMemoryVar(location)){
			String register = value;
			// attempting to move from memory to memory, illegal in LIR
			// must first move value to register, then move register value to location
			if(isMemoryVar(value)){
				register = d.makeNewRegister();
				// move value to register
				d.addLirInstruction(MoveEnum.MOVE, value, register, lineNum);				
			}
			// move from register to location
			d.addLirInstruction(MoveEnum.MOVE, register, location, lineNum);
		}

		// handle a move to a field
		// field is of format 'Reg.Reg' or 'Reg.Immediate'
		else if(location.contains(".")){
			d.addLirInstruction(MoveEnum.MOVE_FIELD, value, location, lineNum);
		}

		// handle a move to an array-location
		// only array ends with ']'
		else if(location.endsWith("]")){ 
			d.addLirInstruction(MoveEnum.MOVE_ARRAY, value, location, lineNum);
		}
	}

	/**
	 * Translate Assignment statement into LIR code
	 */
	public LirReturnInfo visit(AssignStmt stmt, Environment d) {
		
		// get the assignment right-hand-side info first
		LirReturnInfo valueInfo = stmt.getRhs().accept(this, d);
		String valueReg = valueInfo.getRegisterLocation(); // register where value is stored
		
		// get the label of the assignment location
		LirReturnInfo locationInfo = stmt.getLocation().accept(this, d);
		String locationReg = locationInfo.getRegisterLocation(); // register where location is stored
		
		// handle the assignment
		lirAssignHandler(locationReg, valueReg, stmt.getLineNum(), d);
		return null;
	}

	/**
	 * Translate Call statement into LIR code
	 */
	public LirReturnInfo visit(CallStmt callStmt, Environment d) {
		callStmt.getCall().accept(this, d);
		return null;
	}


	/**
	 * Translate Return statement into LIR code
	 */
	public LirReturnInfo visit(ReturnStmt returnStmt, Environment d) {
		String currentReg = null;

		// returns non-void
		if(returnStmt.hasExpr()){
			// get register the return expression is in
			LirReturnInfo returnInfo = returnStmt.getExpr().accept(this, d);
			currentReg = returnInfo.getRegisterLocation();
		}
		// a return void statement, we return dummy
		else{
			currentReg = "Rdummy";
		}
		d.addLirInstruction("Return", currentReg, returnStmt.getLineNum());
		return null;
	}


	/**
	 * Translates If statements to LIR code
	 */
	public LirReturnInfo visit(IfStmt ifStmt, Environment d) {
		String else_label = d.addLabel("else_label"); //label to jump to case of else 
		String end_if_label = d.addLabel("end_if_label");//label to jump to when if stmt ends

		// go over if condition and the register where the result is
		LirReturnInfo condLirInfo = ifStmt.getCond().accept(this, d);
		String condResRegister = condLirInfo.getRegisterLocation();

		// check if the condition holds
		d.addLirInstruction("Compare", "0", condResRegister, ifStmt.getLineNum());
		// if condition is false jump directly to else/end label
		if(ifStmt.hasElse()){
			// jump to else label
			d.addLirInstruction("JumpTrue", else_label, ifStmt.getLineNum()); 
		}else{
			// no else - jump to end label
			d.addLirInstruction("JumpTrue", end_if_label, ifStmt.getLineNum());
		}

		// get if body LIR code
		ifStmt.getBody().accept(this, d);
		d.addLirInstruction("Jump", end_if_label, ifStmt.getLineNum());// then jump to end-if label

		// get else body, if exists
		if(ifStmt.hasElse()){
			d.addLirInstruction(else_label+":", "", ifStmt.getLineNum()); // else_label: 
			ifStmt.getElseStmt().accept(this, d);
		}

		// add if statement end_label
		d.addLirInstruction(end_if_label+":", "", ifStmt.getLineNum());  	
		return null; // does not return value
	}


	/**
	 * Translate While statement into LIR code
	 */
	public LirReturnInfo visit(WhileStmt whileStmt, Environment d) {

		String testLabel = d.addLabel("while_test_label"); //label for while condition test
		String endLabel = d.addLabel("while_end_label"); //label to jump to when while loop over
		//for break, continue statements:
		d.setLoopTestLabel(testLabel);
		d.setLoopEndLabel(endLabel);

		// go over while condition LIR code
		d.addLirInstruction(testLabel+":", "", whileStmt.getLineNum()); // while_test_label:
		LirReturnInfo condInfo = whileStmt.getCond().accept(this, d);
		String condResRegister = condInfo.getRegisterLocation();

		// check if the condition holds
		d.addLirInstruction("Compare", "0", condResRegister, whileStmt.getLineNum());
		// if condition does not hold, end the while loop
		d.addLirInstruction("JumpTrue", endLabel, whileStmt.getLineNum());
		// id condition holds: execute the while body, check the condition when done
		whileStmt.getBody().accept(this, d);
		d.addLirInstruction("Jump", testLabel, whileStmt.getLineNum());

		// add while statement end_label
		d.addLirInstruction(endLabel+":", "", whileStmt.getLineNum()); 
		return null;
	}


	/**
	 * Translate Break statement into LIR code
	 */
	public LirReturnInfo visit(BreakStmt breakStmt, Environment d) {
		// get the enclosing loop end_label to jump to when we break
		String loopEndLabel = d.getLoopEndLabel();
		d.addLirInstruction("Jump", loopEndLabel, breakStmt.getLineNum());
		return null;
	}


	/**
	 * Translate Continue statement into LIR code
	 */
	public LirReturnInfo visit(ContinueStmt continueStmt, Environment d) {
		// get the enclosing loop test_label to jump to when we continue loop
		String loopTestLabel = d.getLoopTestLabel();
		d.addLirInstruction("Jump", loopTestLabel, continueStmt.getLineNum());
		return null;
	}

	/**
	 * Translate a Definition of local variable into LIR code
	 */
	public LirReturnInfo visit(IDStmt idStmt, Environment d) {
		// if the variable statement contained an initial value,
		// we translate the value, and move it to the variable's memory location
		if(idStmt.hasValue()){
			
			// get the register where the value is stored
			LirReturnInfo initialValueInfo = idStmt.getValue().accept(this, d);
			String reg = initialValueInfo.getRegisterLocation();
			
			// get the label of the local variable
			MethodSymbolTable mst = (MethodSymbolTable) idStmt.getScope();
			VariableSymbol localVarSym;
			try {
				localVarSym = mst.getVarSymbolLocal(idStmt.getName());
				String varLabel = localVarSym.getLabel();
				lirAssignHandler(varLabel, reg, idStmt.getLineNum(), d);
			} catch (SemanticError e) {
				// in case method symbol table does not contain parameter
				// should never get here, already checked in Semantic part
				e.printStackTrace();
			}			
			
		}
		return null;
	}

	/**
	 * Translate Block statement list into LIR code
	 */
	public LirReturnInfo visit(BlockStmt blockStmt, Environment d) {
		// iterate over the statements inside the {} block
		return blockStmt.getStatementList().accept(this,d);
	}

	/**
	 * Translate Statements list into LIR code
	 */
	public LirReturnInfo visit(StmtList stmtLst, Environment d) {
		// iterate over the statements
		for(Stmt stmt : stmtLst.getStatements()){
			stmt.accept(this, d);
		}
		return null;
	}

	public LirReturnInfo visit(VarLocation var_loc, Environment d) {
		int reg = d.getCurrentRegister();
		
		if (var_loc.getLocation() != null){
			LirReturnInfo location_expr = var_loc.getLocation().accept(this, d);
			d.addLirInstruction(location_expr.getMoveCommand().toString(), location_expr.getRegisterLocation(), "R"+reg);
			
			//runtime check
			d.addLirInstruction("StaticCall", "__checkNullRef(a=R"+reg+")", "Rdummy");
			
			//field offset
			types.Type class_type = (types.Type)(var_loc.getLocation().accept(new TypeEvaluator(globalSymTable), null));
			String class_name = new String();
			if(class_type instanceof types.TypeClass)
				class_name = class_type.getName();
			else
				System.err.println("Error in line 310\n");
			
			FieldSymbol f = globalSymTable.getClassSymbolTable(class_name).getFieldSymbol(var_loc.getName());
			int offset = f.getOffset()+1;
			
			return new LirReturnInfo(MoveEnum.MOVE_FIELD,"R"+reg+"."+offset);
		}
		else{
			//field
			if (((BlockSymbolTable)var_loc.getScope()).isField(var_loc.getName())){
				String class_name = ((BlockSymbolTable)var_loc.getScope())
						.getEnclosingClassSymbolTable().getSymbol().getName();
				//field offset
				FieldSymbol f = globalSymTable.getClassSymbolTable(class_name).getFieldSymbol(var_loc.getName());
				int offset = f.getOffset()+1;
				String register = "R"+reg+"."+offset;
				
				d.addLirInstruction("Move", "this", "R"+reg);
				return new LirReturnInfo(MoveEnum.MOVE_FIELD,register);

			} 
			//local variable
			else {
				BlockSymbolTable var_block = (BlockSymbolTable)var_loc.getScope();
				String label="";
				try {
					label = var_block.getVarSymbol(var_loc.getName()).getLabel();
				} 
				catch (SemanticError e) {
					//will never get here
				}
				return new LirReturnInfo(MoveEnum.MOVE,label);
			}
		}
	}
	
	//edited by lior:
	public LirReturnInfo visit(ArrLocation arr_loc, Environment d) {
		String arrayLoc = "R" + d.getCurrentRegister();
		
		//array location
		LirReturnInfo location_expr = arr_loc.getArrLocation().accept(this, d);
		
		//we need to transfer the location only if it Memory as
		//Move array instruction supports only registers
		if(location_expr.getRegisterLocation().charAt(0)!='R'){
			d.addLirInstruction(location_expr.getMoveCommand().toString(), location_expr.getRegisterLocation(),arrayLoc);
			d.incrementRegister();
		}else{
			arrayLoc = location_expr.getRegisterLocation();
		}
		
		//runtime check
		d.addLirInstruction("StaticCall", "__checkNullRef(a="+arrayLoc+")","Rdummy");
		
		//index
		//edited by lior: removed decrement optimization currently - lets make it work firstly
		//without optimizations
		LirReturnInfo index = arr_loc.getIndex().accept(this, d);
		String indexLoc = "";
		
		//again we only need to make a move instruction if index location is a Memory
		//as Move Array does not support operations on memories
		if(index.getRegisterLocation().charAt(0) != 'R'){
			indexLoc = "R" + d.getCurrentRegister();
			d.incrementRegister();
			d.addLirInstruction(index.getMoveCommand().toString(), index.getRegisterLocation(),"R"+(reg+1));
			
		}

		//runtime check
		d.addLirInstruction("StaticCall", "__checkArrayAccess(a=R"+reg+",i=R"+(reg+1)+")","Rdummy");
		
		return new LirReturnInfo(MoveEnum.MOVE_ARRAY,"R"+reg+"[R"+(reg+1)+"]");
	}
	
	//Edited by lior:
	public LirReturnInfo visit(StaticCall static_call, Environment d) {
		//Line changed by lior:
		String reg = "R"+d.getCurrentRegister();
		d.incrementRegister();
		String code;
		
		String class_name = static_call.getClassName();
		String method_name = static_call.getMethodName();
		if (static_call.getClassName().equals("Library"))
			code = "_"+method_name+"(";
		else
			code = "_"+class_name+"_"+method_name+"(";
		
		int i = 0;
		int arg_num = static_call.getArguments().size();
		for (Expr arg: static_call.getArguments()){
			LirReturnInfo arg_expr = arg.accept(this, d);
			if (!static_call.getClassName().equals("Library")){
				code += globalSymTable.getClassSymbolTable(class_name)
						.getMethodSymbol(method_name).getFormalNames().get(i);
				code+="=";
			}
			
			code+=arg_expr.getRegisterLocation();
			if(i != arg_num-1){
				code+=",";
			}
			i++;
		}
		code += ")";
		
		//library method call
		if (static_call.getClassName().equals("Library")){
			d.addLirInstruction("Library", code, reg);
		}
		else{
			d.addLirInstruction("StaticCall", code, reg);
		}
		return new LirReturnInfo(MoveEnum.MOVE,reg);
	}

	//method edited by lior
	public LirReturnInfo visit(VirtualCall virtual_call, Environment d) {
		int reg = d.getCurrentRegister();
		d.addToLirStringBuilder("#virtual call to "+virtual_call.getMethodName()+"'s location:\n");
		Expr obj_ref = virtual_call.getObjectReference();
		String objLoc = ""; //added by lior

		if (obj_ref != null){
			LirReturnInfo location = obj_ref.accept(this, d);
			
			//added by lior: no need for that
			//as we call to object it can't be memory by recursive calls
			//if it could me memory then we had to use this command.
			//d.addLirInstruction(location.getMoveCommand().toString(),location.getRegisterLocation(),"R"+reg);

			//runtime check
			d.addLirInstruction("StaticCall","__checkNullRef(a="+location.getRegisterLocation()+")","Rdummy");
			objLoc = location.getRegisterLocation();
		} 
		else {
			d.addLirInstruction("Move","this","R"+reg);
			objLoc = "R"+reg;
		}
		
		//get class name
		String class_name;
		if(obj_ref == null)
			class_name = ((symbolTableHandler.BlockSymbolTable)virtual_call.getScope())
			.getEnclosingClassSymbolTable().getSymbol().getName();
		else
			class_name = ((types.TypeClass)obj_ref.accept(new TypeEvaluator(globalSymTable), null)).getName();
		
		//get method name
		String method_name = virtual_call.getMethodName();
		
		//calculate method offset in virtul table
		int offset = d.getMethodOffset(class_name, method_name);
		
		//add beginning of instruction
		d.addToLirStringBuilder("VirtualCall "+objLoc+"."+offset);
		
		//virtual call's arguments
		//int i = reg+1;
		
		String code = "(";
		int arg_num = virtual_call.getArguments().size();;
		int i=0;
		for (Expr arg: virtual_call.getArguments()){
			//d.incrementRegister();
			LirReturnInfo arg_expr = arg.accept(this, d);
			code += globalSymTable.getClassSymbolTable(class_name)
					.getMethodSymbol(method_name).getFormalNames().get(i)+"="+arg_expr.getRegisterLocation();
			if(i != arg_num-1)
				code+=",";
			//d.addLirInstruction(arg_expr.getMoveCommand().toString(),arg_expr.getRegisterLocation(),"R"+i);
			i++;
		}
		//for(int j=0; j<(i-reg-1); j++)
		//	d.decrementRegister();

		//ask for new register
		String newReg = "R" + d.getCurrentRegister();
		d.incrementRegister();
		
		code += "),"+newReg+"\n";

		d.addToLirStringBuilder(code);
		
		
		return new LirReturnInfo(MoveEnum.MOVE,newReg);
	}

	public LirReturnInfo visit(This t, Environment d) {
		int reg = d.getCurrentRegister();
		d.addLirInstruction("Move","this","R"+reg);

		return new LirReturnInfo(MoveEnum.MOVE,"R"+reg);
	}

	public LirReturnInfo visit(NewObject new_obj, Environment d) {
		int reg = d.getCurrentRegister();

		String class_name = new_obj.getClassName();
		int size = 4 * globalSymTable.getClassSymbolTable(class_name).getCurrentClassFieldOffset() + 4;
		d.addLirInstruction("Library","__allocateObject("+size + ")","R"+reg);
		d.addLirInstruction(MoveEnum.MOVE_FIELD,"_DV_" + class_name,"R"+reg+".0");

		return new LirReturnInfo(MoveEnum.MOVE,"R"+reg);
	}

	public LirReturnInfo visit(NewArray new_arr, Environment d) {
		int reg = d.getCurrentRegister();

		LirReturnInfo array_len_expr = new_arr.getArrayLength().accept(this, d);
		d.addLirInstruction(array_len_expr.getMoveCommand().toString(),
				array_len_expr.getRegisterLocation(),"R"+reg);
		//get the actual length in bytes (multiply register by 4, in place)
		d.addLirInstruction("Mul","4","R"+reg);

		//runtime check
		d.addLirInstruction("StaticCall","__checkSize(n=R"+reg+")","Rdummy");

		//library function - allocate memory for a new array
		d.addLirInstruction("Library","__allocateArray(R"+reg+")","R"+reg);

		return new LirReturnInfo(MoveEnum.MOVE,"R"+reg);
	}

	public LirReturnInfo visit(Length length, Environment d) {
		LirReturnInfo array_expr = length.getExpression().accept(this, d);
		
		//runtime check
		d.addLirInstruction("StaticCall","__checkNullRef(a="+array_expr.getRegisterLocation()+")","Rdummy");

		d.addLirInstruction("ArrayLength",array_expr.getRegisterLocation(),"R"+d.getCurrentRegister());	
		String res = "R"+d.getCurrentRegister();
		d.incrementRegister();
		
		return new LirReturnInfo(MoveEnum.MOVE,res);
	}

	public LirReturnInfo visit(Literal literal, Environment d) {
		String code = "";

		switch (literal.getType()){
		case TRUE:
			code = "1";
		case FALSE:
			code = "0";
			break;
		case NULL:
			code = "0";
			break;
		case STRING:
			String str_value = ((String) literal.getValue()).replaceAll("\n", "\\\\n");
			if (!d.containedInStringToLabelMap(str_value))
				d.addStringLabel(str_value);
			code = d.getStringLabel(str_value);
			break;
		case INTEGER:
			code = literal.getValue().toString();
			break;
		}

		return new LirReturnInfo(MoveEnum.MOVE, code);
	}

	//abstract class Expr, will never get here
	public LirReturnInfo visit(Expr expr, Environment d) {
		throw new RuntimeException("visiting Expr");
	}

	public LirReturnInfo visit(BlockExpr expr, Environment d) {
		return expr.accept(this, d);
	}

	public LirReturnInfo visit(UnaryOpExpr expr, Environment d) {
		LirReturnInfo operand = expr.getOperand().accept(this, d);

		if(expr.hasMathematicalOp())
			return visitMathUnaryExpr(expr, d, operand.getRegisterLocation());
		return visitLogicalUnaryExpr(expr, d, operand.getRegisterLocation());
	}

	public LirReturnInfo visitMathUnaryExpr(UnaryOpExpr expr, Environment d, String operand_reg) {
		d.addLirInstruction("Neg",operand_reg);
		return new LirReturnInfo(MoveEnum.MOVE,operand_reg);
	}

	public LirReturnInfo visitLogicalUnaryExpr(UnaryOpExpr expr, Environment d, String operand_reg) {
		String true_label = "_true_label"+d.getLabelIndex();
		String end_label = "_end_label"+d.getLabelIndex();
		d.incrementLabelIndex();

		d.addLirInstruction("Compare","0",operand_reg);
		d.addLirInstruction("JumpTrue",true_label);
		d.addLirInstruction("Move","0",operand_reg);
		d.addLirInstruction("Jump",end_label);
		d.addToLirStringBuilder(true_label+":\n");
		d.addLirInstruction("Move","1",operand_reg);
		d.addToLirStringBuilder(end_label+":\n");

		return new LirReturnInfo(MoveEnum.MOVE, operand_reg);
	}

	public LirReturnInfo visit(BinaryOpExpr expr, Environment d) {
		LirReturnInfo operand1 = expr.getLeftOperand().accept(this, d);

		//d.incrementRegister();
		LirReturnInfo operand2 = expr.getRightOperand().accept(this, d);

		if(expr.hasMathematicalOp())
			return visitMathBinaryExpr(expr, d, operand1.getRegisterLocation(), operand2.getRegisterLocation());
		return visitLogicalBinaryExpr(expr, d, operand1.getRegisterLocation(), operand2.getRegisterLocation());
	}

	public LirReturnInfo visitMathBinaryExpr(BinaryOpExpr expr, Environment d, String operand1_reg, String operand2_reg ){		
		String res = operand2_reg;
		switch (expr.getOp()){
		case PLUS:
			types.Type lhs_type = (types.Type) expr.getLeftOperand().accept(new TypeEvaluator(globalSymTable), null);
			//mathematical addition
			if (lhs_type.toString().compareTo("int") == 0){
				d.addLirInstruction("Add",operand2_reg,operand1_reg);
			}
			//string concatenation
			else {
				d.addLirInstruction("Library","__stringCat("+operand1_reg+","+operand2_reg+")","R"+d.getCurrentRegister());
				res = "R"+d.getCurrentRegister();
				d.incrementRegister();
			}
			break;
		case MINUS:
			d.addLirInstruction("Sub",operand2_reg,operand1_reg);
			break;
		case MULTIPLY:
			d.addLirInstruction("Mul",operand2_reg,operand1_reg);
			break;
		case DIVIDE:
			//runtime check
			d.addLirInstruction("StaticCall","__checkZero(b="+operand2_reg+")","Rdummy");
			d.addLirInstruction("Div",operand2_reg,operand1_reg);
			break;
		case MOD:
			d.addLirInstruction("Mod",operand2_reg,operand1_reg);
			break;
		default:
			System.err.println("error");//will not get here
		}

		return new LirReturnInfo(MoveEnum.MOVE,res);
	}

	public LirReturnInfo visitLogicalBinaryExpr(BinaryOpExpr expr, Environment d, String operand1_reg, String operand2_reg){
		String true_label = "_true_label"+d.getLabelIndex();
		String false_label = "_false_label"+d.getLabelIndex();
		String end_label = "_end_label"+d.getLabelIndex();
		d.incrementLabelIndex();

		//for relational operators
		if (expr.getOp() != BinOperator.LAND && expr.getOp() != BinOperator.LOR){
			d.addLirInstruction("Compare",operand2_reg,operand1_reg);
		}

		switch (expr.getOp()){
		case LAND:
			d.addLirInstruction("Compare","0",operand1_reg);
			d.addLirInstruction("JumpTrue",false_label);
			d.addLirInstruction("Compare","0",operand2_reg);
			d.addLirInstruction("JumpTrue",false_label);
			d.addLirInstruction("Jump",true_label);
			d.addToLirStringBuilder(false_label+":\n");
			break;
		case LOR:
			d.addLirInstruction("Compare","0",operand1_reg);
			d.addLirInstruction("JumpFalse",true_label);
			d.addLirInstruction("Compare","0","R"+operand2_reg);
			d.addLirInstruction("JumpFalse",true_label);
			break;
		case LT:
			d.addLirInstruction("JumpL",true_label);
			break;
		case GT:
			d.addLirInstruction("JumpG",true_label);
			break;
		case LTE:
			d.addLirInstruction("JumpLE",true_label);
			break;
		case GTE:
			d.addLirInstruction("JumpGE",true_label);
			break;
		case EQUAL:
			d.addLirInstruction("JumpTrue",true_label);
			break;
		case NEQUAL:
			d.addLirInstruction("JumpFalse",true_label);
			break;
		default:
			System.err.println("error");//will not get here	
		}

		//false label
		d.addLirInstruction("Move","0",operand1_reg);	
		d.addLirInstruction("Jump",end_label);

		d.addToLirStringBuilder(true_label+":\n");
		d.addLirInstruction("Move","1",operand1_reg);
		d.addToLirStringBuilder(end_label+":\n");

		return new LirReturnInfo(MoveEnum.MOVE,operand2_reg);
	}
}
