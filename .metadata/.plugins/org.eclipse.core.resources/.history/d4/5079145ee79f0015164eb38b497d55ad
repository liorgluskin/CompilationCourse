package semantic;


import java.util.ArrayList;
import java.util.List;

import slp.*;
import symbolTableHandler.*;
import types.*;
import types.Type;

public class SemanticEvaluator implements Visitor{
	private Boolean hasMain = false;
	private Boolean isLibraryClassVisiting = false;
	private GlobalSymbolTable global = null;
	private SymbolTable currentSymbolTable = null;
	
	private  SymbolTable getCurrentSymbolTable(){
		return currentSymbolTable;
	}
	
	private void setCurrentSymbolTable(SymbolTable symT){
		currentSymbolTable = symT;
	}
	

	
	public SemanticEvaluator(){
		TypeTable.initTypeTable();
	}
	
	public GlobalSymbolTable getSymbolTable(Program program){
		program.accept(this);
		return global;
	}
	
	
	private static boolean isMain(MethodSymbol method_sym){
		//main must be static
		if (!method_sym.isStatic()) return false;						
		if (method_sym.getName().compareTo("main") != 0) return false;
		
		TypeMethod type_method = (TypeMethod)method_sym.getType();
		try{
			//return type must be void
			if (type_method.getReturnType() != (TypeTable.getType("void"))) return false; 
			
			//no parameters or too many
			if (type_method.getParamTypes().size() != 1) return false; 
			
			//parameter is not of type string[]
			types.Type param_type = type_method.getParamTypes().get(0);
			if (param_type != TypeTable.typeArray(TypeTable.getType("string"))) return false;
		}
		catch(SemanticError se){}
		return true;
	}
	
	
	//should be done before starting visit.
	//visit should 'visit' this class too and add to 
	private void addStaticLibraryClass(Program program){
		//creating all methods
		List<FieldOrMethod> methodsLst = new ArrayList<>();
		
		//println added
		List<Formal> printlnFormals = new ArrayList<>(); 
		printlnFormals.add(new Formal(new PrimitiveType(-1, DataTypes.STRING), "s"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.VOID),"println",printlnFormals,new StmtList()));
		
		//print added
		List<Formal> printFormals = new ArrayList<>(); 
		printFormals.add(new Formal(new PrimitiveType(-1, DataTypes.STRING), "s"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.VOID),"print",printFormals,new StmtList()));
		
		//printi added
		List<Formal> printiFormals = new ArrayList<>(); 
		printiFormals.add(new Formal(new PrimitiveType(-1, DataTypes.INT), "i"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.VOID),"printi",printiFormals,new StmtList()));
		
		//readi
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.INT),"readi",new ArrayList<Formal>(),new StmtList()));
		
		//readln
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.STRING),"readln",new ArrayList<Formal>(),new StmtList()));
		
		//eof
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.BOOLEAN),"eof",new ArrayList<Formal>(),new StmtList()));
		
		//stoi
		List<Formal> stoi = new ArrayList<>(); 
		stoi.add(new Formal(new PrimitiveType(-1, DataTypes.STRING), "s"));
		stoi.add(new Formal(new PrimitiveType(-1, DataTypes.INT), "n"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.INT),"stoi",stoi,new StmtList()));
		
		//itos
		List<Formal> itos = new ArrayList<>(); 
		itos.add(new Formal(new PrimitiveType(-1, DataTypes.INT), "i"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.STRING),"itos",itos,new StmtList()));
		
		
		//stoa
		List<Formal> stoa = new ArrayList<>(); 
		itos.add(new Formal(new PrimitiveType(-1, DataTypes.STRING), "s"));
		PrimitiveType t = new PrimitiveType(-1, DataTypes.INT);
		t.incrementDimension();
		methodsLst.add(new StaticMethod(t,"stoa",stoa,new StmtList()));
		
		//atos
		List<Formal> atos = new ArrayList<>();
		PrimitiveType t_atos = new PrimitiveType(-1, DataTypes.INT);
		t.incrementDimension();
		atos.add(new Formal(t, "a"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.STRING),"atos",atos,new StmtList()));
		
		//random
		List<Formal> random = new ArrayList<>();
		random.add(new Formal(new PrimitiveType(-1, DataTypes.INT), "i"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.INT),"random",random,new StmtList()));
		
		//random
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.VOID),"time",new ArrayList<Formal>(),new StmtList()));
		
		//exit
		List<Formal> exit = new ArrayList<>();
		exit.add(new Formal(new PrimitiveType(-1, DataTypes.INT), "i"));
		methodsLst.add(new StaticMethod(new PrimitiveType(-1, DataTypes.INT),"exit",exit,new StmtList()));
		
		//declaring class
		ClassDecl libraryClass = new ClassDecl(-2, "Library",methodsLst);
		List<ClassDecl> classes = program.getClasses();
		Collections.reverse(classes);
		classes.add(libraryClass);
		Collections.reverse(classes);
	}


	@Override
	public void visit(Program program){
		global = new GlobalSymbolTable();
		addStaticLibraryClass(program);
		// add classes to global and updates the type table
		for (ClassDecl c: program.getClasses()){
			try{
				global.addClass(c);
			} catch (SemanticError se){
				// class is previously defined or super class is not defined
				se.setLineNum(c.getLineNum());
				System.err.println(se);
				System.exit(-1);
			}
		}
		
		// recursive class symbol tables build
		for (ClassDecl c: program.getClasses()){
			setCurrentSymbolTable(global);
			
			// set enclosing scope
			c.setEnclosingScope(global);
			c.accept(this);
		}
		
		// check if has main method
		if (!hasMain){
			System.err.println(new SemanticError("Program has no main method",0));
			System.exit(-1);
		}
	}


	@Override
	public void visit(ClassDecl class_decl) {
		if(class_decl.getName() == "Library"){
			isLibraryClassVisiting = true;
		}
		
		//create symbol table for class 
		ClassSymbolTable cst;		
		if (class_decl.getSuperClassName() != null) {
			ClassSymbolTable  scst = global.getClassSymbolTable(class_decl.getSuperClassName());
			cst = new ClassSymbolTable( scst, global.getClass(class_decl.getName()) );
			scst.addClassSymbolTable(cst);
		} else { // no superclass
			cst = new ClassSymbolTable(global,global.getClass(class_decl.getName()));
			global.addClassSymbolTable(cst);;
		}
		
		
		
		//create symbol table for methods 
		for( FieldOrMethod fom: class_decl.getFieldsOrMethods()){
			fom.setEnclosingScope(cst);
			
		}
		
		
		
		
		//fields and methods check
		
		
		//reset LibraryClassVisit
		isLibraryClassVisiting = false;
	}


	@Override
	public void visit(ClassMethod method) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(StaticMethod method) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(PrimitiveType primitiveType) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(ClassType classType) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Field field) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Formal formal) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(StmtList stmts) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Stmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(AssignStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(CallStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(ReturnStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(IfStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(WhileStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(BreakStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(ContinueStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(BlockStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(IDStmt stmt) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(VarLocation var_loc) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(ArrLocation arr_loc) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(StaticCall static_call) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(VirtualCall virtual_call) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Literal literal) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(This t) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(NewObject new_obj) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(NewArray new_arr) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Length length) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(Expr expr) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(BlockExpr expr) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(UnaryOpExpr expr) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void visit(BinaryOpExpr expr) {
		// TODO Auto-generated method stub
		
	}
}
